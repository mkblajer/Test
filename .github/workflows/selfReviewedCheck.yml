name: Self-Reviewed Check

permissions:
  pull-requests: write
  contents: read

on:
  pull_request:
    types: [closed]

jobs:
  self_review_check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Load config
        id: config
        run: |
          CONFIG=$(jq -c . .github/workflows/config.json)
          echo "config=$CONFIG" >> $GITHUB_OUTPUT
          
      - name: Check for self-reviewed PR
        env:
            CONFIG: ${{ steps.config.outputs.config }}
        
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // read config from json file
            const config = JSON.parse(process.env.CONFIG);
            
            // check if merged
            const pr = context.payload.pull_request;
            if (pr.merged) {
              // --------------------------------------------------
              const reviewerPool = config.reviewerPool;
              const backupReviewer = config.backupReviewer;
              
              const labelsList = config.labels;
              
              const srMessage = config.selfReviewed;
              const nrMessage = config.notReviewed;

              const assignedMessage = config.assignReviewer;
              const notAssignedMessage = config.noReviewer;
              
              // --------------------------------------------------
                
              // get pull request number
              const prNumber = context.payload.pull_request.number;
  
              // get data of all reviews
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
  
              // get data of all commits
              const { data: commits } = await github.rest.pulls.listCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
  
              const reviewers = new Set(reviews.map(r => r.user.login));
              const authors = new Set(commits.map(c => c.author.login));
              
              // check if there's only one reviewer and it's also the author of a commit
              if ((reviewers.size == 1 && [...reviewers][0] && authors.has([...reviewers][0])) || (reviewers.size == 0)) {
                
                // Filter out authors of the PR
                const prAuthor = context.payload.pull_request.user.login;

                const availableReviewers = reviewerPool.filter(u => u !== prAuthor && !authors.has(u));

  
                // comment describing the issue
                if (reviews.size == 0){
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: nrMessage
                  });
                } else{
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: srMessage
                  });
                }

                
                if (availableReviewers.length == 0) {
                  console.log("No eligible reviewers left. Cannot assign automatically.");
                  
                  // comment reporting error
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: notAssignedMessage
                  });
                  
                  if (backupReviewer != null){
                    // request backup reviewer
                    await github.rest.pulls.requestReviewers({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber,
                      reviewers: [backupReviewer]
                    });
                    
                    // comment instructions
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: prNumber,
                      body: `@${backupReviewer}` + assignedMessage
                    });
                  }
                } else {
                  const selectedReviewer = availableReviewers[Math.floor(Math.random() * availableReviewers.length)];
  
                  // request reviewer
                  await github.rest.pulls.requestReviewers({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                    reviewers: [selectedReviewer]
                  });
  
                  // comment instructions
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: `@${selectedReviewer}` + assignedMessage
                  });
  
                  // add labels
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    labels: labelsList
                  });
  
                  console.log(`Assigned @${selectedReviewer} for post-merge review.`);
                }
                
                // fail self-reviewed check
                console.log(`Number of reviews: ${reviews.size}`)
                if (reviews.size == 0){
                  console.log("This PR is not reviewed.");
                  core.setFailed("This PR is not reviewed");
                }
                core.setFailed("This PR is self-reviewed")
                  
              } else {
                console.log("PR is not self-reviewed.");
              }
            }
            
